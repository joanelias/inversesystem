////////////////////////////////////////////////////////////////////
version="$Id: inverse-syst-v.5.3.lib 2017-07-17 $";
category="Commutative Algebra";
info="
This library computes the  one-to-one correspondence of 
Macaulay's inverse system for Artin rings. The structure of
S=k[x_1,...,x_n] as R=k[[x_1,...,x_n]]-module is by derivation 
or by contraction(i.e. without coefficients, here NC). 

The ground ring should be defined with a local ordering, i.e.
	ring r=p,(x(1..n)),ord; 
	p is the charcateristic, n is an integer, and 
	ord is a local ordering: ds, ls or Ds.

A R-submodule of S generated by F_1,...,F_r is handled 
in this LIB as an ideal generated by F_1,...,F_r.


LIBRARY: inverse-syst-v.4.lib     
AUTHOR:  Joan Elias
         email: elias@ub.edu

PROCEDURES:
LINEAR ALGEBRA
nonzeroE(M); M a matrix. 
	Returns the matrix [0,0] if M=0, and
	returns the matrix [i,j] if the (i,j) entry of M is not zero
roucheF(M,C); M a matrix and C a vector. 
	Returns -2 if the dimensions of M and C are not compatible,
	returns -1 if the system of equations M*X=C is not compatible, 
	returns 0 if is compatible but no determined, and 
	returns 1 	if the system is compatible and determined
solveSystEqs(M,C); M a matrix and C a col matrix. 
	We consider the system of equations M*X=C.
	Returns -1 if the number of cols of M does not agree with the 	
	number of rows of C, 	or if the system of equations M*X=C is not compatible.
	Returns 0 and  a k-base of M*X=0 if the system is homogeneous.
	Returns 1, a sol. of the system of equations and a k-base of  	
	M*X=0 if the system is not homogeneous  and is not determined.
	Returns 2 and the solutions of the system of equations if it is 	
	not homogeneous and compatible determined.
IDEAL THEORY
genPol(i,j,a). 
	Returns a generic polinomial sum of forms of degrees 	
	between i and j, with integer coefficients in [-a,a].
genPol(i, j, k,a)
	Returns a generic polinomial sum of forms of degrees 	
	between i and j, on the first k vars with integer 	coefficients in [-a,a].
isSubset(J,I); I, J ideals. 
	Returns 1 if J is a subset of I, 
	return 0 	otherwise.
eqIdeal(J,I); I, J ideals. 
	Returns 1 if I=J, 0 otherwise.
delGenId(I, i); I ideal, i integer. 
	Returns  the ideal generated by the generators of I 
	but the i-th.
socle(J); I ideal 
	Returns -1 if J is not Artin, 
	returns the  ideal of J if J is Artin.
cmType(J); J ideal. 
	Returns -1 if J is not Artin, 
	returns the  Cohen-Macaulay type of J otherwise.
isAG(I); I ideal. 
	Returns -2 if J is not Artin, 
	returns -1 if J is 	Artin but not Gorenstein, and 
	returns the socle degree if J 	is Artin Gorenstein.
isLevel(I); I ideal. 
	Returns -2 if J is not Artin, 
	returns -1 if is Artin but not Level, and 
	returns the socle degree if J is Artin Level

MACAULAY INVERSE SYSTEM CORRESPONDENCE WITH COEFFICIENTS
invSystG(ideal J) 
	returns the inverse system of J; J is Artin Gorenstein
invSyst(J)   
	returns the inverse system of J; J is Artin
idealAnnG(poly f) 
	returns the Artin Gorenstein ideal with inverse system f
idealAnn(I) 
	returns the Artin  ideal with inverse system I

STRUCTURE OF INJECTIVE HULL WITH COEFFICIENTS
memberIH(g,I); I=f1,... list of polynomials, g polynomial. 
	returns 1 	if g belongs to the R-submodule of S 
	generated by f1,...fs in S, 
	returns 0, otherwise
subModIH(I,J); I=f1,... list of polynomials, J=g1,... list of polynomials 
	Returns 1 if I is a sub-R-submodule of J, both 
	sub-R-modules of S; 
	0 otherwise
eqModIH(I,J); I=f1,... list of polynomials, J=g1,... list of polynomials 
	Returns 1 if I=J, both sub-R-modules of S; 
	0 otherwise
minGensIH(I); I=f1,...,fs list of polynomials. 
	Returns a minimal  system of generators of <f1,...,fs>, 
	sub-R-module of S
colonInvSyst(f,g); f, g polynomials. 
	Returns an element g of R such 	that Aof=g if exists, 
	0 otherwise.

MACAULAY INVERSE SYSTEM CORRESPONDENCE WITH NO COEFFICIENTS
invSystGNC(ideal J) 
	returns the inverse system of J; J is Artin Gorenstein
invSystNC(J)   
	returns the inverse system of J; J is Artin
idealAnnGNC(poly f) 
	returns the Artin Gorenstein ideal with inverse system f
idealAnnNC(I) 
	returns the Artin  ideal with inverse system I

STRUCTURE OF INJECTIVE HULL WITH NO COEFFICIENTS
memberIHNC(g,I); I=f1,... list of polynomials, g polynomial. 
	returns 1 if g belongs to the R-submodule of S generated by f1,...fs in S, 
	returns 0 otherwise
subModIHNC(I,J); I=f1,... list of polynomials, J=g1,... list of polynomials. 
	Returns 1 if I is a sub-R-submodule of J, both sub-R-modules 
	of S; 	
	returns 0 otherwise
eqModIHNC(I,J); I=f1,... list of polynomials, J=g1,... list of polynomials. 
	Returns 1 if I=J, both sub-R-modules of S;
	returns 0 	otherwise
minGensIHNC(I); I=f1,...,fs list of polynomials. 
	Returns a minimal system of generators of <f1,...,fs>, sub-R-module of S
colonInvSystNC(f,g); f, g polynomials. 
	Returns an element g of R such that Aof=g if exists, 
	returns 0 otherwise.

RINGS WITH PARAMETERS
workringc(p, t, n)
	returns the def of  a ring  r with 
	t coefFicients c	(1),...,c(t), 
	n vars x(1),...,x(n), char is p, 
	and order ds

ELLIPTIC CURVES
weiertrassj(t)
	returns the ideal generated by weierstrass equation 
	of the elliptic curve with j invariant
idealwj(t)
	returns the ideal with inverse system weierstrassj(j)
weiertrassp()
	returns the iddeal generated by weierstrass equation of the 	
	elliptic curve with moduli j=c(1), where c(1) is a parameter.
idealwp(t)
	returns the ideal with inverse system weierstrassp()
	with moduli j=c(1), where c(1) is a parameter.

TEST
testFromIdeal(ideal I) composition of invSyst and idealAnn, 
	should return 1.
testFromInvSyst(ideal I) composition of idealAnn and invSyst, 
	should return 1.
testFromIdealNC(ideal I) composition of invSystNC and idealAnnNC, should return 1.
testFromInvSystNC(ideal I) composition of idealAnnNC and invSystNC, should return 1.
";

LIB "matrix.lib"
LIB "multigrading.lib"
LIB "presolve.lib"
LIB "general.lib"




/////////////////////////////////////////////////////////////////////////////////////// LINEAR ALGEBRA /////////////////////////////////

proc nonzeroE(matrix M)
USAGE:   nonzeroE(M); M a matrix
RETURN:   returns the matrix [0,0] if M=0
returns the matrix [i,j] if the entry (i,j) of M is not zero
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example nonzeroE; shows an example"

{
int i;
int j;
intmat G[2][1]=0,0; 
for(j=1; j<=ncols(M); j=j+1)
	{for(i=1; i<=nrows(M); i=i+1)
		{if(M[i,j]!=0)
			{intmat G[2][1]=i,j; return(G);}
		}
	}
intmat G[2][1]=0,0; 
return(G);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
matrix M[2][2]=0,0,0,0;
nonzeroE(M);
matrix M[2][2]=0,0,0,1;
nonzeroE(M);
}

////////////////////////////////////////////////////////////////////
proc roucheF(matrix M, matrix C)
"USAGE:   roucheF(M,C); M a matrix and C a col matrix
RETURN:   Returns -2 if the number of cols of M does not agree with the number of rows of C.
Returns -1 if the system of equations M*X=C is not compatible.
Returns 0 if is compatible but no determined 
Returns 1 if it is compatible and determined
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example roucheF; shows an example"

{
if(nrows(M)!=nrows(C))
	{return(-2);}
int a=rank(M);
matrix N=concat(M,C);
if(a!=rank(N))
  	{return(-1); }
if(a==ncols(M))
  	{return(1);}
return(0);}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
matrix M[2][2]=1,2,3,4;
matrix C[3][1]=1,2,2;
roucheF(M,C);
matrix M[2][2]=1,2,2,4;
matrix C[2][1]=1,3;
roucheF(M,C);
matrix C[2][1]=1,2;
roucheF(M,C);
matrix M[2][2]=1,2,3,4;
matrix C[2][1]=1,3;
roucheF(M,C);
}





////////////////////////////////////////////////////////////////////
proc solveSystEqs(matrix M, matrix C)
"USAGE:   solveSystEqs(M,C); M a matrix and C a col matrix
RETURN:   We consider the system of equations M*X=C.
Returns -1 if the number of cols of M does not agree with the number 	of rows of C, or if the system of equations M*X=C is not 	compatible.
Returns 0 and  a k-base of M*X=0 if the system is homogeneous.
Returns 1, a sol. of the system of equations, and a k-base of M*X=0, 	if the system is not homogeneous and is not determined.
Returns 2 and the sol of the system of equations if it is not 	homogeneous and compatible determined.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example solveSystEqs; shows an example"

{
if(roucheF(M,C)<0)
	{list L=-1;return(L);}
matrix F[nrows(M)][1]=0;
if(C==F)
	{list L=0, matrix(modulo(M,std(0))); return(L);}
matrix K=modulo(M,C);
matrix W=M*K;
intmat G=nonzeroE(W);
matrix H=modulo(M,std(0));
if (roucheF(M,C)==1)
	{list L=2, (C[G[1,1],1]/W[G[1,1],G[2,1]])*submat(K,1..nrows(K),G[2,1]);
	return(L);
	}
list L=1, (C[G[1,1],1]/W[G[1,1],G[2,1]])*submat(K,1..nrows(K),G[2,1]),H;
	return(L);
}

example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
matrix M[2][2]=1,2,3,4;
matrix C[3][1]=1,2,2;
solveSystEqs(M,C);
matrix M[2][2]=1,2,2,4;
matrix C[2][1]=1,3;
solveSystEqs(M,C);
matrix C[2][1]=1,2;
solveSystEqs(M,C);
matrix M[2][2]=1,2,3,4;
matrix C[2][1]=1,3;
solveSystEqs(M,C);
}

///////////////////////////////////////////////////////////////////////////////////// IDEAL THEORY /////////////////////////////////////
////////////////////////////////////////////////////////////////////


proc genPol(int i, int j, int a)
"USAGE:   genPol(i,j,a)
RETURN:   Returns a generic polinomial sum of forms of degrees between i and j, with integer coeffs in -a,a.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example genPol; shows an example"

{
int t;
poly g=0;
for (t=i; t<=j; t=t+1)
{g=g+randommat(1,1,maxideal(t),a)[1,1];}
return(g);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
genPol(2,3,6);
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

proc genPol(int i, int j, int k, int a)
"USAGE:   genPol(i,j,k,a)
RETURN:   Returns a generic polinomial sum of forms of degrees between i and j, on the k first vars, 
with integer coeffs in -a,a.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example genPol; shows an example"

{
int t;
poly g=0;
matrix H[1][k]=0;
for (t=1; t<=k; t=t+1)
{H[1,t]=var(t);
}
ideal T=H;
for (t=i; t<=j; t=t+1)
{
g=g+randommat(1,1,T^t,a)[1,1];}
return(g);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
genPol(2,3,1,6);
}


////////////////////////////////////////////////////////////////////
proc isSubset(ideal J, ideal I)
"USAGE:   isSubset(J,I); I, Jideal
RETURN:   returns 1 if J is a subset of I, 0 otherwise.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isSubset; shows an example"

{
if(nvars(basering)-dim(std(reduce(std(J),std(I))))==0)
	  {return(1);}
	else
	{return(0);}
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
ideal I=x^2;
ideal J1=y;
ideal J2=x^4;
isSubset(J1,I);
isSubset(J2,I)
}

////////////////////////////////////////////////////////////////////
proc eqIdeal(ideal J, ideal I)
"USAGE:   eqIdeal(J,I); I, J ideals
RETURN:   returns 1 if I=J, 0 otherwise.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example eqIdeal; shows an example"

{
if (isSubset(I,J)+isSubset(J,I)>1)
	{return(1);}
return(0);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
ideal I=x^2;
ideal J1=y;
ideal J2=x^4;
isSubset(J1,I);
isSubset(J2,I);
}

////////////////////////////////////////////////////////////////////
proc delGenId(ideal I, int i)
"USAGE:   delGenId(I, i); I ideal, i integer
RETURN:   the ideal generated by the generators of I but the i-th
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example delGenId; shows an example"
{
int s=size(I);
if (i>s)
	{return(I);}
ideal Z=0;
if (s==1)
	{return(Z);}
if (i>1)
	{ideal J=I[1];
		for (int j=2;j<=size(I);j++)
  		    {if (j!= i) {J=J,I[j];}
			}
	}
	else
	{ideal J=I[2]; 
		for (int j=3;j<=size(I);j++)
  		    {J=J,I[j];}
			
}
return(J);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(1)^3,x(2),x(3)^4;
delGenId(I,2);
}

////////////////////////////////////////////////////////////////////
proc socle(ideal J)
"USAGE:   socle(J); J ideal
RETURN:   returns -1 if J is not Artin, returns the socle ideal of R/J if J is Artin 
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example socle; shows an example"
{
ideal K1=std(J);
if(dim(K1)!=0)
  {  return(-1); }
ideal K2=std(quotient(K1,maxideal(1)));
return(K2);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
ideal I=x^2,y^3*x;
socle(I);
ideal I=x^2,y^3;
socle(I);
}

////////////////////////////////////////////////////////////////////
proc cmType(ideal J)
"USAGE:   cmType(J); J ideal
RETURN:   returns -1 if J is not Artin, returns the Cohen-Macaulay type of R/J if J is Artin 
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example cmType; shows an example"
{
ideal K1=std(J);
if(dim(K1)!=0)
  {  return(-1); }
ideal K2=std(quotient(K1,maxideal(1)));
return(vdim(K1)-vdim(K2));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
ideal I=x^2,y^3*x;
cmType(I);
ideal I=x^2,y^3;
cmType(I);
}


////////////////////////////////////////////////////////////////////
proc isAG(ideal J)
"USAGE:   isAG(I); I ideal
RETURN:   returns -2 if J is not Artin, returns -1 if is Artin but not Gorenstein, 
		and returns the socle degree if J is 	Artin Gorenstein
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isAG; shows an example"

{
ideal K1=std(J);
if(dim(K1)!=0)
  {  return(-2); }
ideal K2=std(quotient(K1,maxideal(1)));
if(vdim(K1)-vdim(K2)!=1)
  {return(-1);}
return(size(hilb(K1,2))-2);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
ideal I=x^2,y^3;
isAG(I);
ideal I=x^2;
isAG(I);
ideal I=maxideal(3);
isAG(I);
}

////////////////////////////////////////////////////////////////////
proc isLevel(ideal J)
"USAGE:   isLevel(I); I ideal
RETURN:   returns -2 if J is not Artin, returns -1 if is Artin but not Level
		and returns the socle degree if J is  Artin Level
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isLevel; shows an example"
{
ideal K1=std(J);
if(dim(K1)!=0)
  {  return(-2); }
int s=size(hilb(K1,2))-2;
if(vdim(std(socle(J)+K1))==vdim(std(K1+maxideal(s))))
  {return(s);};
return(-1);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y),ds;
ideal I=x^2,y^3*x;
isAG(I);
ideal I=x^2;
isLevel(I);
ideal I=maxideal(3);
isLevel(I);
}

/////////////////////////////////////////////////////////////////////////////////MACAULAY INVERSE SYSTEM CORRESPONDENCE/////////
///////////////////////////////////////////////////////////////

proc invSystG(ideal J)
"USAGE:   invSystG(J); J ideal
RETURN:  returns the inverse system of J; J is Artin Goresntein 
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSystG; shows an example"
{
int s=isAG(J);
int j;
if(s <0)
	{return("is not an Artin Gorenstein ring ");}
list M=kbase(std(maxideal(s+2)));
int t=size(J);
if(t==1)
	{matrix P=transpose(coeffs(diff(J[1],M[1])));}
	else
	{matrix P=concat(transpose(coeffs(diff(J[1],M[1]),M[1])),
		transpose(coeffs(diff(J[2],M[1]),M[1])));}
if(t>2)
	{for(j=3;j<=t;j=j+1)
		{P=concat(P,transpose(coeffs(diff(J[j],M[1]),M[1])));	}
	}
matrix Q=modulo(transpose(P),std(0));
matrix T=transpose(Q)*transpose(M[1]);
for (j=1; j<=size(T); j=j+1)
	{if(deg(T[j,1])==s)
		{return(T[j,1]);
		}
	}
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(2)*x(3),x(1)*x(3),x(1)*x(2),x(2)^3-x(3)^3,x(1)^3-x(3)^3;
//the inverse system of I is:
invSystG(I);
}

/////////////////////////////////////////////////////////////////

proc invSyst(ideal J)
"USAGE:   invSyst(J); J ideal
RETURN:  returns the inverse system of J; J is Artin
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSyst; shows an example"
{
if (isAG(J)<-1)
	{return("is not an Artin ring");}
int s=size(hilb(std(J),2))-2;
list M=kbase(std(maxideal(s+2)));
int t=size(J);
if(t==1)
	{matrix P=transpose(coeffs(diff(J[1],M[1])));}
	else
	{matrix P=concat(transpose(coeffs(diff(J[1],M[1]),M[1])),
		transpose(coeffs(diff(J[2],M[1]),M[1])));}
int j;
if(t>2)
	{for(j=3;j<=t;j=j+1)
		{P=concat(P,transpose(coeffs(diff(J[j],M[1]),M[1])));	}
	}
matrix Q=modulo(transpose(P),std(0));
matrix T=transpose(Q)*transpose(M[1]);
ideal K=T[1,1];
for (j=2; j<=size(T); j=j+1)
	{K=K,T[j,1];}
return(minGensIH(K));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(2)*x(3),x(1)*x(3),x(1)*x(2),x(2)^3-x(3)^2,x(1)^3-x(3)^3;
//the inverse system of I is:
invSyst(I);
}

/////////////////////////////////////////////////////////////////

proc idealAnnG(poly f)
"USAGE:   idealAnnG(f); f polynomial
RETURN:   returns the Artin Gorenstein ideal with inverse system f
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnnG; shows an example"
{
int s=deg(f);
ideal I=std(f);
list M=kbase(std(maxideal(s+2)));
matrix P=modulo(coeffs(transpose(diff(M[1],I)),M[1]),std(0));
return(minbase(flatten(transpose(P)*transpose(M[1]))));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
poly f=x(1)^3+x(2)^3+x(3)^3;
// the ideal with inverse system f is:
ideal I=idealAnn(f);
I;
// if we compute the inverse system of this ideal
invSystG(I);
//we get f
}

/////////////////////////////////////////////////////////////////

proc idealAnn(ideal  I)
"USAGE:   idealAnn(I); I=f1,...,fs list of polynomials
RETURN:   returns the Artin  ideal with inverse system 
is generated by f1,...,fs
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnn; shows an example"
{
int s=size(I);
if (s==1){return(idealAnnG(I[1]));
};
int i;
ideal J=idealAnnG(I[1]);
ideal K;
for (i=2; i<s+1;i++)
{
K =intersect(J,idealAnnG(I[i]));
J=K;
};
return(std(J));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal J= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
// the ideal with inverse system generated by the generators of I:
ideal I=idealAnn(J);
I;
//its inverse system is
invSyst(I);
}

/////////////////////////////////////////////////////////////////
///////////////HOMOGENEOUS ////////////////////////////////////
/////////////////////////////////////////////////////////////////

proc invSystH(ideal J,int d)
"USAGE:   invSyst(J,d); J ideal, d integer
RETURN:  returns the inverse system of J up tp degree d; J is homogeneous and Artin
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSystH; shows an example"
{
if (isAG(J)<-1)
	{return("is not an Artin ring");}
if(isHomogeneous(J)== 0)
	{return("is not homogeneous");}
list M=kbase(std(maxideal(d+1)));
int t=size(J);
if(t==1)
	{matrix P=transpose(coeffs(diff(J[1],M[1])));}
	else
	{matrix P=concat(transpose(coeffs(diff(J[1],M[1]),M[1])),
		transpose(coeffs(diff(J[2],M[1]),M[1])));}
int j;
if(t>2)
	{for(j=3;j<=t;j=j+1)
		{P=concat(P,transpose(coeffs(diff(J[j],M[1]),M[1])));	}
	}
matrix Q=modulo(transpose(P),std(0));
matrix T=transpose(Q)*transpose(M[1]);
ideal K=0;
for (j=1; j<=size(T); j=j+1)
	{if(deg(T[j,1]) == d)
		{K=K, T[j,1];}
	};
return(K);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(2)*x(3),x(1)*x(3),x(1)*x(2),x(2)^3-x(3)^2,x(1)^3-x(3)^3;
//the inverse system of I up to degree 5 is:
invSystH(I);
}

/////////////////////////////////////////////////////////////////

proc idealAnnGH(poly f, int d)
"USAGE:   idealAnnGH(f,d); f homogeneos polynomial integer d
RETURN:   returns the Artin Gorenstein ideal with inverse system the homogeneous form f up to degree d
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnnGH; shows an example"
{
int s=deg(f);
ideal I=f;
list M=kbase(std(maxideal(d+1)));
list L=kbase(std(maxideal(s+2)));
matrix P=modulo(coeffs(transpose(diff(M[1],I)),L[1]),std(0));
return(minbase(flatten(transpose(P)*transpose(M[1]))));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
poly f=x(1)^3+x(2)^3+x(3)^3;
// the ideal with inverse system f up tp degree 5 is:
ideal I=idealAnn(f,5);
I;
// if we compute the inverse system of this ideal up to degree 5
invSystGH(I,5);
//we get f
}

/////////////////////////////////////////////////////////////////

proc idealAnnH(ideal  I, int d)
"USAGE:   idealAnn(I,t); I=f1,...,fs list of homogeneous polynomials, d an integer
RETURN:   returns the Artin  ideal with inverse system 
is generated by f1,...,fs up to degree d
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnn; shows an example"
{
if(isHomogeneous(I)== 0)
	{return("is not homogeneous");}
int s=size(I);
if (s==1){return(idealAnnGH(I[1],d));
};
int i;
ideal J=idealAnnGH(I[1],d);
ideal K;
for (i=2; i<s+1;i++)
{
K =degreepart(intersect(J,idealAnnGH(I[i],d)),0,d)[1];
J=K;
};
return(minbase(J));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal J= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
// the ideal with inverse system generated by the generators of I:
ideal I=idealAnnH(J,5);
I;
//its inverse system is
invSystH(I,5);
}


//////////////////////////////////////////////////////////////////////////STRUCTURE OF INJECTIVE HULL////////////////////////////
/////////////////////////////////////////////////////////////////

///////////////////MEMBERSHIP IN THE INJECTIVE HULL////////////

proc memberIH(poly g,ideal  I)
"USAGE:   memberIH(g,I); I=f1,... list of polynomials, g polynomial
RETURN:   returns 1 if g belongs to the R-submodule of S generated by f1,...fs in S, 0 otherwise
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example memberIH; shows an example"
{
return(isSubset(idealAnn(I),idealAnnG(g)));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3;
memberIH(x(2),F);
memberIH(x(2)*x(3),F);
}

///////////////////SUBMODULE QUERY IN THE  INJECTIVE HULL////////

proc subModIH(ideal I, ideal J)
"USAGE:   subModIH(I,J); I=f1,... list of polynomials, J=g1,... list of  polynomials
RETURN:   returns 1 if I is a sub-R-submodule of J, both sub-R-modules of S; o otherwise
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example subModIH; shows an example"
{
int i;
for (i=1; i<=size(I);i=i+1)
{if (memberIH(I[i],J)==0)
 {return(0);};}
return(1);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
ideal G= x(1)^2,x(3)^2;
subModIH(G,F);
}

////////////////EQUALITY MODULE QUERY IN THE  INJECTIVE HULL/////

proc eqModIH(ideal I, ideal J)
"USAGE:   eqModIH(I,J); I=f1,... list of polynomials, J=g1,... list of  polynomials
RETURN:   returns 1 if I=J, both sub-R-modules of S; o otherwise
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example eqModIH; shows an example"
{
if (subModIH(I,J)+subModIH(J,I)>1)
 {return(1);}
return(0);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
ideal G= F, x(1)^2+x(3)^2;
eqModIH(G,F);
}

/////////MINIMALIZE A SYSTEM OF GENERATORS OF A /////////
//////////SUB-R-MODULE IN THE INJECTIVE HULL////////

proc minGensIH(ideal  I)
"USAGE:   minGensIH(I); I=f1,...,fs list of polynomials
RETURN:   returns a minimal system of generators of <f1,...,fs>, sub-R-module of S
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example minGensIH; shows an example"
{
int c=1;
ideal K=I;
int j=1;
while (c)
{
if ( memberIH(K[j], delGenId(K,j)))
	{K=delGenId(K,j);}
	else
	{j=j+1;}
if (j> size(K))
	{c=0;}
}
return(K);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
ideal G= F, x(1)^2+x(3)^2;
minGensIH(G);
}

/////////////////////////////////////////////////////////////////

proc colonInvSyst(poly f, poly g)
"USAGE:   colonInvSyst(f,g); f, g polynomials
RETURN:   returns an element A of R such that Aof=g if exists , 0 otherwise.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example colonInvSyst; shows an example"
{
int s=deg(f);
if (deg(g)>s)
	{return(0);}
ideal I=std(f);
ideal J=std(g);
list M=kbase(std(maxideal(s+2)));
list P=solveSystEqs(coeffs(transpose(diff(M[1],I)),M[1]),coeffs(J,M[1]));
int a=P[1];
if (a==-1)
{return(0);}
return(std(flatten(transpose(P[2])*transpose(M[1]))));
}

example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
poly F= x(1)^3+x(2)^3+x(3)^3;
poly f=x(2);
colonInvSyst(F,f);
}

//////////////////////////////////////////////////////////////////////MACAULAY INVERSE SYSTEM CORRESPONDENCE NO COEFFICENTS /////
/////////////////////////////////////////////////////////////////

proc invSystGNC(ideal J)
"USAGE:   invSystGNC(J); J ideal
RETURN:  returns the inverse system of J; J is Artin Goresntein 
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSystGNC; shows an example"

{
int s=isAG(J);
int j;
if(s <0)
	{return("is not an Artin Gorenstein ring ");}
list M=kbase(std(maxideal(s+2)));
int t=size(J);
if(t==1)
	{matrix P=transpose(coeffs(contract(J[1],M[1])));}
	else
	{matrix P=concat(transpose(coeffs(contract(J[1],M[1]),M[1])),
		transpose(coeffs(contract(J[2],M[1]),M[1])));}
if(t>2)
	{for(j=3;j<=t;j=j+1)
		{P=concat(P,transpose(coeffs(contract(J[j],M[1]),M[1])));	}
	}
matrix Q=modulo(transpose(P),std(0));
matrix T=transpose(Q)*transpose(M[1]);
for (j=1; j<=size(T); j=j+1)
	{if(deg(T[j,1])==s)
		{return(T[j,1]);
		}
	}
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(2)*x(3),x(1)*x(3),x(1)*x(2),x(2)^3-x(3)^3,x(1)^3-x(3)^3;
//the inverse system of I is:
invSystGNC(I);
}

/////////////////////////////////////////////////////////////////

proc invSystNC(ideal J)
"USAGE:   invSystNC(J); J ideal
RETURN:  returns the inverse system of J; J is Artin
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSystNC; shows an example"
{
if (isAG(J)<-1)
	{return("is not an Artin ring");}
int s=size(hilb(std(J),2))-2;
list M=kbase(std(maxideal(s+2)));
int t=size(J);
if(t==1)
	{matrix P=transpose(coeffs(contract(J[1],M[1])));}
	else
	{matrix P=concat(transpose(coeffs(contract(J[1],M[1]),M[1])),
		transpose(coeffs(contract(J[2],M[1]),M[1])));}
int j;
if(t>2)
	{for(j=3;j<=t;j=j+1)
		{P=concat(P,transpose(coeffs(contract(J[j],M[1]),M[1])));	}
	}
matrix Q=modulo(transpose(P),std(0));
matrix T=transpose(Q)*transpose(M[1]);
ideal K=T[1,1];
for (j=2; j<=size(T); j=j+1)
	{K=K,T[j,1];}
return(minGensIHNC(K));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(2)*x(3),x(1)*x(3),x(1)*x(2),x(2)^3-x(3)^3,x(1)^3-x(3)^3;
//the inverse system of I is:
invSystNC(I);
}

/////////////////////////////////////////////////////////////////

proc idealAnnGNC(poly f)
"USAGE:   idealAnnGNC(f); f polynomial
RETURN:   returns the Artin Gorenstein ideal with inverse system f
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnnGNC; shows an example"

{
int s=deg(f);
ideal I=std(f);
list M=kbase(std(maxideal(s+2)));
matrix P=modulo(coeffs(transpose(contract(M[1],I)),M[1]),std(0));
return(std(flatten(transpose(P)*transpose(M[1]))));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
poly f=x(1)^3+x(2)^3+x(3)^3;
// the ideal with inverse system f is:
ideal I=idealAnnNC(f);
I;
// if we compute the inverse system of this ideal
invSystGNC(I);
//we get f
}

/////////////////////////////////////////////////////////////////

proc idealAnnNC(ideal  I)
"USAGE:   idealAnnArtinNC(I); I=f1,...,fs list of polynomials
RETURN:   returns the Artin  ideal with inverse system 
is generated by f1,...,fs
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnnNC; shows an example"
{
int s=size(I);
if (s==1){return(idealAnnGNC(I[1]));}
int i;
ideal J=idealAnnGNC(I[1]);
ideal K;
for (i=2; i<s+1;i++)
{
K =intersect(J,idealAnnGNC(I[i]));
J=K;
};
return(std(J));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal J= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
// the ideal with inverse system generated by the generators of I:
ideal I=idealAnnNC(J);
I;
//its inverse system is
invSystNC(I);
}

///////////////////////////////////////////////////////
////////////////////HOMOGENEOUS///////////////////////
//////////////////////////////////////////////////////

proc invSystHNC(ideal J, int d)
"USAGE:   invSystNC(J,d); J ideal, d an integer
RETURN:  returns the inverse system of J up to degree d; J is Artin
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSystNC; shows an example"
{
if (isAG(J)<-1)
	{return("is not an Artin ring");}
list M=kbase(std(maxideal(d)));
list L=minbase(maxideal(d));
int t=size(J);
if(t==1)
	{matrix P=transpose(coeffs(contract(J[1],L[1]),M[1]));}
	else
	{matrix P=concat(transpose(coeffs(contract(J[1],L[1]),M[1])),
		transpose(coeffs(contract(J[2],L[1]),M[1])));}
int j;
if(t>2)
	{for(j=3;j<=t;j=j+1)
		{P=concat(P,transpose(coeffs(contract(J[j],L[1]),M[1])));	}
	}
matrix Q=modulo(transpose(P),std(0));
matrix T=transpose(Q)*transpose(L[1]);
ideal K=0;
for (j=1; j<=size(T); j=j+1)
	{if(deg(T[j,1]) == d)
		{K=K, T[j,1];}
	}
return(K);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal I=x(2)*x(3),x(1)*x(3),x(1)*x(2),x(2)^3-x(3)^3,x(1)^3-x(3)^3;
//the inverse system of I up to degree 6 is:
invSystHNC(I,6);
}

/////////////////////////////////////////////////////////////////

proc idealAnnGHNC(poly f, int d)
"USAGE:   idealAnnGNC(f,d); f homogeneous polynomial, d an integer
RETURN:   returns the Artin Gorenstein ideal with inverse system f up to degree d
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnnGNC; shows an example"

{
int s=deg(f);
ideal I=f;
list M=kbase(std(maxideal(d+1)));
list L=kbase(std(maxideal(s+2)));
matrix P=modulo(coeffs(transpose(contract(M[1],I)),L[1]),std(0));
return(minbase(flatten(transpose(P)*transpose(M[1]))));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
poly f=x(1)^3+x(2)^3+x(3)^3;
// the ideal with inverse system f is:
ideal I=idealAnnGHNC(f,5);
I;
// if we compute the inverse system of this ideal
invSystGHNC(I,5);
//we get f
}

/////////////////////////////////////////////////////////////////

proc idealAnnHNC(ideal  I, int d)
"USAGE:   idealAnnHNC(I,d); I=f1,...,fs list of homogeneous polynomials, d an integer
RETURN:   returns the Artin  ideal with inverse system 
is generated by f1,...,fs up to degree d
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealAnnNC; shows an example"
{
int s=size(I);
if (s==1){return(idealAnnGHNC(I[1],d));
};
int i;
ideal J=idealAnnGHNC(I[1],d);
ideal K;
for (i=2; i<s+1;i++)
{
K =degreepart(intersect(J,idealAnnGHNC(I[i],d)),0,d)[1];
J=K;
};
return(minbase(J));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal J= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
// the ideal with inverse system generated by the generators of I // up tp degree 6
ideal I=idealAnnHNC(J,6);
I;
//its inverse system is
invSystHNC(I,6);
}

////////////////////////////////////////////////////////////////////////STRUCTURE OF INJECTIVE HULL NO COEFFICIENTS /////////////
/////////////////////////////////////////////////////////////////

////////////////MEMBERSHIP IN THE INJECTIVE HULL////////////////

proc memberIHNC(poly g,ideal  I)
"USAGE:   memberIHNC(g,I); I=f1,... list of polynomials, g polynomial
RETURN:   returns 1 if g belongs to the R-submodule of S generated by f1,...fs in S, 0 otherwise
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example memberIHNC; shows an example"
{
return(isSubset(idealAnnNC(I),idealAnnGNC(g)));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3;
memberIHNC(x(2),F);
memberIHNC(x(2)*x(3),F);
}


/////////////////SUBMODULE QUERY IN THE  INJECTIVE HULL//////////

proc subModIHNC(ideal I, ideal J)
"USAGE:   subModIHNC(I,J); I=f1,... list of polynomials, J=g1,... list of  polynomials
RETURN:   returns 1 if I is a sub-R-submodule of J, both sub-R-modules of S; o otherwise
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example subModIHNC; shows an example"
{
int i;
for (i=1; i<=size(I);i=i+1)
{if (memberIHNC(I[i],J)==0)
 {return(0);};}
return(1);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
ideal G= x(1)^2,x(3)^2;
subModIHNC(G,F);
}


////////////////EQUALITY MODULE QUERY IN THE  INJECTIVE HULL/////

proc eqModIHNC(ideal I, ideal J)
"USAGE:   eqModIHNC(I,J); I=f1,... list of polynomials, J=g1,... list of  polynomials
RETURN:   returns 1 if I=J, both sub-R-modules of S; o otherwise
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example eqModIHNC; shows an example"
{
if (subModIHNC(I,J)+subModIHNC(J,I)>1)
 {return(1);}
return(0);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
ideal G= F, x(1)^2+x(3)^2;
eqModIHNC(G,F);
}

//////MINIMALIZE A SYSTEM OF GENERATORS OF A SUB-R-MODULE /////
//////IN THE INJECTIVE HULL////////

proc minGensIHNC(ideal  I)
"USAGE:   minGensIHNC(I); I=f1,...,fs list of polynomials
RETURN:   returns a minimal system of generators of <f1,...,fs>, sub-R-module of S
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example minGensIHNC; shows an example"
{
int c=1;
ideal K=I;
int j=1;
while (c)
{
if ( memberIHNC(K[j], delGenId(K,j)))
	{K=delGenId(K,j);}
	else
	{j=j+1;}
if (j> size(K))
	{c=0;}
}
return(K);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
ideal F= x(1)^3+x(2)^3+x(3)^3, x(1)*x(2);
ideal G= F, x(1)^2+x(3)^2;
minGensIHNC(G);
}

/////////////////////////////////////////////////////////////////

proc colonInvSystNC(poly f, poly g)
"USAGE:   colonInvSystNC(f,g); f, g polynomials
RETURN:   returns an element A of R such that Aof=g if exists , 0 otherwise.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example colonInvSystNC; shows an example"
{
int s=deg(f);
if (deg(g)>s)
	{return(0);}
ideal I=std(f);
ideal J=std(g);
list M=kbase(std(maxideal(s+2)));
list P=solveSystEqs(coeffs(transpose(contract(M[1],I)),M[1]),coeffs(J,M[1]));
int a=P[1];
if (a==-1)
{return(0);}
return(std(flatten(transpose(P[2])*transpose(M[1]))));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds; 
poly F= x(1)^3+x(2)^3+x(3)^3;
poly f=x(2);
colonInvSystNC(F,f);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ISO BETWEEN THE STRUCUTURES OF THE /////////////
///////////////  INJECTIVE HULL WITH REPECT THE ///////////////
///////////////  CONTRACTION AND THE DERIVATION /////////////////
///////////////// CHARACTERISTIC ZERO ///////////////////////


proc factexp(intvec a)
"USAGE:   factexp(a)
RETURN:   Returns the product of the factorials of the entries of the intvec a
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example factexp; shows an example"

{
int t;
bigint g=1;
for (t=1; t<=nrows(a); t=t+1)
{g=g*factorial(a[t]);}
return(g);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y,z),ds;
intvect a=2,1,0,3;
factexp(a);
}


////////////////////////////////////////////////////////////////////

proc isoCon2DiffP(poly f)
"USAGE:   isoCon2Diff(f)
RETURN:   Returns the image of f by the iso between
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isoCon2Diff; shows an example"

{
poly v=1;
int t;
for (t=1; t<=nvars(basering); t=t+1)
{v=v*var(t);}
matrix L=coef(f,v);
poly g=0;
for (t=1; t<=ncols(L); t=t+1)
{g=g+(L[1,t]*L[2,t]/factexp(leadexp(L[1,t])));}
return(g);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y,z),ds;
intvect a=2,1,0,3;
factexp(a);
}

////////////////////////////////////////////////////////////////////

proc isoCon2Diff(ideal J)
"USAGE:   isoCon2Diff(J)
RETURN:   Returns the image of J by the iso between
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isoCon2Diff; shows an example"

{
ideal I=0;
int t;
for (t=1; t<=size(J); t=t+1)
{I=I,isoCon2DiffP(J[t]);}
return(minbase(I));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y,z),ds;
intvect a=2,1,0,3;
factexp(a);
}


////////////////////////////////////////////////////////////////////

proc isoDiff2ConP(poly f)
"USAGE:   isoDiff2Con(f)
RETURN:   Returns the image of f by the iso between
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isoDiff2Con; shows an example"

{
poly v=1;
int t;
for (t=1; t<=nvars(basering); t=t+1)
{v=v*var(t);}
matrix L=coef(f,v);
poly g=0;
for (t=1; t<=ncols(L); t=t+1)
{g=g+(L[1,t]*L[2,t]*factexp(leadexp(L[1,t])));}
return(g);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y,z),ds;
intvect a=2,1,0,3;
factexp(a);
}

////////////////////////////////////////////////////////////////////

proc isoDiff2Con(ideal J)
"USAGE:   isoCon2Diff(J)
RETURN:   Returns the image of J by the iso between
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example isoCon2Diff; shows an example"

{
ideal I=0;
int t;
for (t=1; t<=size(J); t=t+1)
{I=I,isoDiff2ConP(J[t]);}
return(minbase(I));
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x,y,z),ds;
intvect a=2,1,0,3;
factexp(a);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////RINGS WITH PARAMETERS/////////////
/////////////////////////////////////////////////////////////////

proc workringc(int p, int t, int n)
"USAGE:   workring(p, t,n);  t, n integers
RETURN:   returns the def of  a ring r with 
t coeficeints c(1),...,c(t) and n vars
x(1),...,x(n), char is p, and  order ds
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example m; shows an example"

{
return(defring(string(p)+",(c(1.."+string(t)+"))",n,"x(","ds"));
}
example
{ "EXAMPLE:";echo=2;
def r=workringc(6,2);
setring r;
r;
}


/////////////////////////////////////////////////////////////////////////////////  ELLIPTIC CURVES     //////////////////////////
/////////////////////////////////////////////////////////////////

proc weierstrassj(int j)
"USAGE:   weiertrassj(t); 
RETURN:  the iddeal generated by weierstrass equation of the elliptic curve with j invariant
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSyst; shows an example"

{if(j==0)
{
ideal i=x(2)^2*x(3)-x(1)^3 + x(2)*x(3)^2;
return(i);}
if(j==1728)
{
ideal i=x(2)^2*x(3)-x(1)^3 - x(1)*x(3)^2;
return(i);}
ideal i=(j-1728)*(x(2)^2*x(3)+x(1)*x(2)*x(3)-x(1)^3) + 36*x(1)*x(3)^2 +x(3)^3;
return(i);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
weierstrassj(0);
weierstrassj(1728);
weierstrassj(2);
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

proc idealwj(int j)
"USAGE:   idealwj(t); 
RETURN: return the ideal with inverse system weierstrassj(j)
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example invSyst; shows an example"
{
if(j==0)
{
ideal i=x(3)^3,x(1)^3+3*x(2)^2*x(3), x(1)*x(3),x(2)^2-x(2)*x(3)+x(3)^2,x(1)*x(2);
return(i);}
if(j==1728)
{
ideal i=x(2)^2+x(1)*x(3),x(1)*x(2),x(1)^2-3*x(3)^2;
return(i);}
ideal i=6*j*x(1)*x(2)-144*(j-1728)*x(1)*x(3)+72*(j-1728)*x(2)*x(3)-(j-1728)^2*x(3)^2, j*x(1)^2-12*(j-1728)*x(1)*x(3)+6*(j-1728)*x(2)*x(3)+144*(j-1728)*x(3)^2, x(2)*(x(2)-2*x(1));
return(i);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
ideal j=invSyst(idealwj(4));
j[1]-weierstrassj(4);
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////  ELLIPTIC CURVES PARAMETER  ///////////////////
/////////////////////////////////////////////////////////////////

proc weierstrassp()
"USAGE:   weiertrassp(); 
RETURN:  the iddeal generated by weierstrass equation of the elliptic curve with moduli j=c(1), ), where c(1) is a parameter.
NOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example weierstrassp(); shows an example"
{ 
ideal i;
ideal i=(c(1)-1728)*(x(2)^2*x(3)+x(1)*x(2)*x(3)-x(1)^3) + 36*x(1)*x(3)^2 +x(3)^3;
return(i);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
weierstrassp();
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

proc idealwp()
"USAGE:   idealwp(t); 
RETURN: return the ideal with inverse system weierstrassp() with moduli j=c(1)), where c(1) is a parameter.
hNOTE:    
SEE ALSO: 
KEYWORDS: procedure, ASCII help
EXAMPLE:  example idealwp(); shows an example"
{
ideal i=6*c(1)*x(1)*x(2)-144*(c(1)-1728)*x(1)*x(3)+72*(c(1)-1728)*x(2)*x(3)-(c(1)-1728)^2*x(3)^2, c(1)*x(1)^2-12*(c(1)-1728)*x(1)*x(3)+6*(c(1)-1728)*x(2)*x(3)+144*(c(1)-1728)*x(3)^2, x(2)*(x(2)-2*x(1));
return(i);
}
example
{ "EXAMPLE:";echo=2;
ring r=0,(x(1..3)),ds;
idealwp();
}


////////////////////////////////////////////////////////////////////////////////////////////////TESTS//////////////////////////////////////////////////////////////////////////////////////////////
// several tests if the above procedures work ok
// ideal->inv syst->ideal
// inv syst-> ideal-> inv syst
/////////////////////////////////////////////////////////////////

proc testFromIdeal(ideal I)
{
ideal J=idealAnn(invSyst(I));
return(eqIdeal(I,J));
}

proc testFromInvSyst(ideal I)
{
ideal J=invSyst(idealAnn(I));
return(eqModIH(I,J));
}

/////////////////////////////////////////////////////////////////
//////////////////NO COEFFICEINTS///////////////////////
/////////////////////////////////////////////////////////////////

proc testFromIdealNC(ideal I)
{
ideal J=idealAnnNC(invSystNC(I));
return(eqIdeal(I,J));
}

proc testFromInvSystNC(ideal I)
{
ideal J=invSystNC(idealAnnNC(I));
return(eqModIHNC(I,J));
}